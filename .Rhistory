#put everything in a dataframe (this is using strings to represent cross type)
df1 <- data.frame(crosstype = c(rep('outbred',93),rep('selfed',83)), daystf = c(outbred,selfed))
ggplot(data = df1, mapping = aes(x = crosstype, y = daystf)) + geom_point()
model1 <- lm(daystf ~ crosstype, data = df1)
summary(model1)
"coefficients: intercept = 35.3454, coefficients = 2.4919, p-value = 4.95e-05"
knitr::opts_chunk$set(echo = TRUE)
set.seed(777) ##pick a number to set your seed here
doExp <- function(i){
myX <- runif(100) #sample 100 random numbers
myY <- runif(100) #sample 100 random numbers
myModel = lm(myY ~ myX) #fit linear model
myP = summary(myModel)$coefficients[2,4] #get p value
return(myP)
}
nTests=1000
simulated_pvalues <- sapply(1:nTests, doExp) ## run doExp 200 times
simulated_pvalues
hist(simulated_pvalues)
FWER <- 1 - (1-0.05)^100
FWER
FWER <- 1 - (1-0.05)^1000 #family-wide error rate
FWER
sum(simulated_pvalues < 0.05)
Bonf_cut_off <- 0.05/1000
sum(simulated_pvalues < Bonf_cut_off)
FDR <- p.adjust(simulated_pvalues, method = "fdr")
FDR
sum(FDR < 0.05)
hist(simulated_pvalues)
# a
FWER <- 1 - (1-0.05)^1000 #family-wide error rate
FWER
# b
sum(simulated_pvalues < 0.05)
"this is much lower than predicted value 1 from part a)"
# c
Bonf_cut_off <- 0.05/1000
sum(simulated_pvalues < Bonf_cut_off)
# d
FDR <- p.adjust(simulated_pvalues, method = "fdr")
sum(FDR < 0.05)
# e
sum(simulated_pvalues < Bonf_cut_off)
myX <- runif(100)
error <- rnorm(100, mean = 0, sd = error_sd)
b_0 <- 2
b_1 <- 1
error_sd <- 0.5
error <- rnorm(100, mean = 0, sd = error_sd)
myY <- b_0 + b_1 * myX + error
doExp1 <- function(i){
myX <- runif(100) #sample 100 random numbers
myY <- runif(100) #sample 100 random numbers
myModel = lm(myY ~ myX) #fit linear model
myP = summary(myModel)$coefficients[2,4] #get p value
return(myP)
}
nTests=1000
simulated_pvalues1 <- sapply(1:nTests, doExp) ## run doExp 200 times
hist(simulated_pvalues1)
#b
sum(simulated_pvalues1 < 0.05)
#c
sum(simulated_pvalues1 < Bonf_cut_off)
#d
FDR1 <- p.adjust(simulated_pvalues1, method = "fdr")
sum(FDR1 < 0.05)
min(FDR1)
b_0 <- 2 #intercept
b_1 <- 1 #effect of X
error_sd <- 0.5 # standard error term
myX <- runif(100)
error <- rnorm(100, mean = 0, sd = error_sd)
myY <- b_0 + b_1 * myX + error
set.seed(777) ##pick a number to set your seed here
doExp1 <- function(i){
myX <- runif(100) #sample 100 random numbers
myY <- runif(100) #sample 100 random numbers
myModel = lm(myY ~ myX) #fit linear model
myP = summary(myModel)$coefficients[2,4] #get p value
return(myP)
}
nTests=1000
simulated_pvalues1 <- sapply(1:nTests, doExp) ## run doExp 200 times
#a
hist(simulated_pvalues1)
#b
sum(simulated_pvalues1 < 0.05)
#c
sum(simulated_pvalues1 < Bonf_cut_off)
#d
FDR1 <- p.adjust(simulated_pvalues1, method = "fdr")
sum(FDR1 < 0.05)
min(FDR1)
hist(simulated_pvalues)
# a
FWER <- 1 - (1-0.05)^1000 #family-wide error rate
FWER
# b
sum(simulated_pvalues < 0.05)
"this is much lower than predicted value 1 from part a"
# c
Bonf_cut_off <- 0.05/1000
sum(simulated_pvalues < Bonf_cut_off)
# d
FDR <- p.adjust(simulated_pvalues, method = "fdr")
sum(FDR < 0.05)
# e
"for a large number of tests like 1000, it's better to use FDR"
#b
sum(simulated_pvalues1 < 0.05)
#c
sum(simulated_pvalues1 < Bonf_cut_off)
#a
hist(simulated_pvalues1)
#b
sum(simulated_pvalues1 < 0.05)
"55"
#c
sum(simulated_pvalues1 < Bonf_cut_off)
"0"
#d
FDR1 <- p.adjust(simulated_pvalues1, method = "fdr")
sum(FDR1 < 0.05)
min(FDR1)
#e
#d
FDR1 <- p.adjust(simulated_pvalues1, method = "fdr")
sum(FDR1 < 0.05)
min(FDR1)
knitr::opts_chunk$set(echo = TRUE)
library(Seurat)
library(dplyr)
library(ggplot2)
library(monocle3)
library(patchwork)
library(glmGamPoi)
library(ggrepel)
library(plyr)
setwd("~/Research")
embryo_11dpf <- load_monocle_objects("data/embryo_11dpf") #load single-cell data monocle3 object
counts_11dpf <- counts(embryo_11dpf) # pull out the counts data
metadata_11dpf <- as.data.frame(colData(embryo_11dpf)) # pull out the metadata
seurat_obj_11dpf <- CreateSeuratObject( #create a seurat object
counts = counts_11dpf,
meta.data = metadata_11dpf,
project = "GarEmbryo_11dpf")
seurat_obj_11dpf <- SCTransform(seurat_obj_11dpf, verbose = FALSE) #normalize counts
seurat_obj_11dpf <- RunPCA(seurat_obj_11dpf, npcs = 30) #reduce dimensionality using top variables
ElbowPlot(seurat_obj_11dpf, ndims = 40) # choose how many PCs to use for downstrean analysis
seurat_obj_11dpf <- FindNeighbors(seurat_obj_11dpf, dims = 1:20) # build KNN graph in PCA space
seurat_obj_11dpf <- FindClusters(seurat_obj_11dpf, resolution = 1.0) # Cluster cell on neighbor graph
seurat_obj_11dpf <- RunUMAP(seurat_obj_11dpf, dims = 1:20) # embed cells in 20 for visualization
DimPlot(seurat_obj_11dpf, group.by = "seurat_clusters", label = TRUE) +
ggtitle("11 dpf Gar – Clusters")
markers_11dpf <- FindAllMarkers(
seurat_obj_11dpf,
only.pos = TRUE,
min.pct = 0.25,
logfc.threshold = 0.25
)
top_markers_11dpf <- markers_11dpf %>%
group_by(cluster) %>%
top_n(n = 50, wt = avg_log2FC)
# GLM on one gene across all clusters (11 dpf)
DefaultAssay(seurat_obj_11dpf) <- "SCT"  # use normalized expression values
geneX <- "col1a1b" #previously identified marker gene
stopifnot(geneX %in% rownames(seurat_obj_11dpf))
# Extract log-normalized expression
expr <- as.numeric(GetAssayData(seurat_obj_11dpf, slot = "data")[geneX, ])
# Build a modeling dataframe
df <- seurat_obj_11dpf@meta.data %>%
mutate(
expr = expr,
seurat_clusters = factor(seurat_clusters)  # categorical predictor
) %>%
select(expr, seurat_clusters)
# Fit the general linear model
fit_real <- lm(expr ~ seurat_clusters, data = df)
# Report coefficients + p-values
summary(fit_real)$coefficients
# plot residuals
plot(fitted(fit_real), resid(fit_real),
xlab = "Fitted values", ylab = "Residuals",
main = "Residuals vs. fitted (real data)")
abline(h = 0, lty = 2)
# Data + model fit plot (required): observed vs predicted
df$pred <- predict(fit_real, newdata = df)
ggplot(df, aes(x = pred, y = expr)) +
geom_point(alpha = 0.35) +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(title = "Observed vs. predicted col1a1b expression (real data)",
x = "Predicted expression", y = "Observed expression")
VlnPlot(seurat_obj_11dpf, features = "col1a1b", group.by = "seurat_clusters", pt.size = 0) +
NoLegend() +
ggtitle("col1a1b expression across clusters (11 dpf)")
BiocManager::install("splatter")
library(scater)
#load programs to simulate single-cell RNA-seq data
library(splatter)
library(SingleCellExperiment)
BiocManager::install("scater")
#load programs to simulate single-cell RNA-seq data
library(splatter)
library(scater)
library(SingleCellExperiment)
set.seed(1)
library(scuttle)
#load programs to simulate single-cell RNA-seq data
library(splatter)
library(scuttle)
library(scater)
library(SingleCellExperiment)
set.seed(1)
#load programs to simulate single-cell RNA-seq data
library(splatter)
library(scuttle)
library(scater)
library(SingleCellExperiment)
set.seed(1)
# H0: NO differences across clusters
params0 <- newSplatParams()
params0 <- setParam(params0, "nGroups", 10)
library(splatter)
library(scuttle)
library(scater)
library(SingleCellExperiment)
set.seed(1)
# number of cells in my real data
n_cells <- ncol(counts(embryo_11dpf))
# number of genes
n_genes <- nrow(counts(embryo_11dpf))
# how many clusters
n_clusters <- length(unique(seurat_obj_11dpf$seurat_clusters))
# cluster sizes (proportions)
cluster_prop <- prop.table(table(seurat_obj_11dpf$seurat_clusters))
n_cells; n_genes; n_clusters; cluster_prop
#number of cells and clusters, and proportions
n_cells <- 1427
n_clusters <- 10
cluster_prop <- c(0.214435879,0.165381920,0.124737211,0.123335669,0.118430273,
0.102312544,0.065872460,0.064470918,0.014716188,0.006306938)
# only use 2000 genes
n_genes_sim <- 2000
# Create group labels with your observed proportions
group <- sample(paste0("c", 0:(n_clusters-1)),
size = n_cells, replace = TRUE, prob = cluster_prop)
# Splatter params
params <- newSplatParams(batchCells = n_cells, nGenes = n_genes_sim)
sce_H0 <- splatSimulate(params, group = group, method = "groups",
verbose = FALSE, dropout.type = "experiment")
n_cells <- 1427
n_clusters <- 10
cluster_prop <- c(0.214435879,0.165381920,0.124737211,0.123335669,0.118430273,
0.102312544,0.065872460,0.064470918,0.014716188,0.006306938)
n_genes_sim <- 2000
# generate cluster labels based on proportions
group <- sample(paste0("c", 0:(n_clusters-1)),
size = n_cells, replace = TRUE, prob = cluster_prop)
# simulate
params <- newSplatParams(batchCells = n_cells, nGenes = n_genes_sim)
sce_H0 <- splatSimulate(params, method = "single", verbose = FALSE)
# attach groups after simulation
colData(sce_H0)$Group <- factor(group, levels = paste0("c", 0:(n_clusters-1)))
# rename one gene to col1b1a
rownames(sce_H0)[1] <- "col1b1a"
params_H1 <- setParams(params, de.prob = 0.1, de.facLoc = 1, de.facScale = 0.3)
sce_H1 <- splatSimulate(params_H1, method = "single", verbose = FALSE)
colData(sce_H1)$Group <- factor(group, levels = paste0("c", 0:(n_clusters-1)))
rownames(sce_H1)[1] <- "col1b1a"
expr <- as.numeric(logcounts(sce_H0)["col1b1a", ])
# generate cluster labels based on proportions
group <- sample(paste0("c", 0:(n_clusters-1)),
size = n_cells, replace = TRUE, prob = cluster_prop)
# simulate (no group effects)
params <- newSplatParams(batchCells = n_cells, nGenes = n_genes_sim)
sce_H0 <- splatSimulate(params, method = "single", verbose = FALSE)
# attach groups after simulation
colData(sce_H0)$cluster <- factor(group, levels = paste0("c", 0:(n_clusters-1)))
# rename one gene to col1b1a
rownames(sce_H0)[1] <- "col1b1a"
# create logcounts
sce_H0 <- logNormCounts(sce_H0)
expr <- as.numeric(logcounts(sce_H0)["col1b1a", ])
df0 <- data.frame(expr = expr, cluster = colData(sce_H0)$cluster)
fit_H0 <- lm(expr ~ cluster, data = df0)
anova(fit_H0)
summary(fit_H0)$r.squared
# start from H0, then add a cluster-specific shift ONLY to col1b1a
sce_H1 <- sce_H0
expr1 <- logcounts(sce_H1)["col1b1a", ]
# example: make clusters c0 and c1 higher (you can change which clusters)
shift <- ifelse(colData(sce_H1)$cluster %in% c("c0","c1"), 1.0, 0)  # +1 log-unit
logcounts(sce_H1)["col1b1a", ] <- expr1 + shift
# test
expr <- as.numeric(logcounts(sce_H1)["col1b1a", ])
df1 <- data.frame(expr = expr, cluster = colData(sce_H1)$cluster)
fit_H1 <- lm(expr ~ cluster, data = df1)
anova(fit_H1)
summary(fit_H1)$r.squared
knitr::opts_chunk$set(echo = TRUE)
library(Seurat)
library(dplyr)
library(ggplot2)
library(monocle3)
library(patchwork)
library(glmGamPoi)
library(ggrepel)
library(plyr)
setwd("~/Research")
embryo_11dpf <- load_monocle_objects("data/embryo_11dpf") #load single-cell data monocle3 object
counts_11dpf <- counts(embryo_11dpf) # pull out the counts data
metadata_11dpf <- as.data.frame(colData(embryo_11dpf)) # pull out the metadata
seurat_obj_11dpf <- CreateSeuratObject( #create a seurat object
counts = counts_11dpf,
meta.data = metadata_11dpf,
project = "GarEmbryo_11dpf")
seurat_obj_11dpf <- SCTransform(seurat_obj_11dpf, verbose = FALSE) #normalize counts
seurat_obj_11dpf <- RunPCA(seurat_obj_11dpf, npcs = 30) #reduce dimensionality using top variables
ElbowPlot(seurat_obj_11dpf, ndims = 40) # choose how many PCs to use for downstrean analysis
seurat_obj_11dpf <- FindNeighbors(seurat_obj_11dpf, dims = 1:20) # build KNN graph in PCA space
seurat_obj_11dpf <- FindClusters(seurat_obj_11dpf, resolution = 1.0) # Cluster cell on neighbor graph
seurat_obj_11dpf <- RunUMAP(seurat_obj_11dpf, dims = 1:20) # embed cells in 20 for visualization
DimPlot(seurat_obj_11dpf, group.by = "seurat_clusters", label = TRUE) +
ggtitle("11 dpf Gar – Clusters")
markers_11dpf <- FindAllMarkers(
seurat_obj_11dpf,
only.pos = TRUE,
min.pct = 0.25,
logfc.threshold = 0.25
)
top_markers_11dpf <- markers_11dpf %>%
group_by(cluster) %>%
top_n(n = 50, wt = avg_log2FC)
# GLM on one gene across all clusters (11 dpf)
DefaultAssay(seurat_obj_11dpf) <- "SCT"  # use normalized expression values
geneX <- "col1a1b" #previously identified marker gene
stopifnot(geneX %in% rownames(seurat_obj_11dpf))
# Extract log-normalized expression
expr <- as.numeric(GetAssayData(seurat_obj_11dpf, slot = "data")[geneX, ])
# Build a modeling dataframe
df <- seurat_obj_11dpf@meta.data %>%
mutate(
expr = expr,
seurat_clusters = factor(seurat_clusters)  # categorical predictor
) %>%
select(expr, seurat_clusters)
# Fit the general linear model
fit_real <- lm(expr ~ seurat_clusters, data = df)
# Report coefficients + p-values
summary(fit_real)$coefficients
# plot residuals
plot(fitted(fit_real), resid(fit_real),
xlab = "Fitted values", ylab = "Residuals",
main = "Residuals vs. fitted (real data)")
abline(h = 0, lty = 2)
# Data + model fit plot (required): observed vs predicted
df$pred <- predict(fit_real, newdata = df)
ggplot(df, aes(x = pred, y = expr)) +
geom_point(alpha = 0.35) +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(title = "Observed vs. predicted col1a1b expression (real data)",
x = "Predicted expression", y = "Observed expression")
VlnPlot(seurat_obj_11dpf, features = "col1a1b", group.by = "seurat_clusters", pt.size = 0) +
NoLegend() +
ggtitle("col1a1b expression across clusters (11 dpf)")
# Does cluster explain expression?
anova(fit_real)
summary(fit_real)$r.squared
library(splatter)
library(scuttle)
library(scater)
library(SingleCellExperiment)
set.seed(1)
# number of cells in my real data
n_cells <- ncol(counts(embryo_11dpf))
# number of genes?
n_genes <- nrow(counts(embryo_11dpf))
# how many clusters?
n_clusters <- length(unique(seurat_obj_11dpf$seurat_clusters))
# cluster sizes (proportions)
cluster_prop <- prop.table(table(seurat_obj_11dpf$seurat_clusters))
n_cells; n_genes; n_clusters; cluster_prop
n_genes_sim <- 2000 #simulate only 2000 genes
cluster_prop <- as.numeric(cluster_prop)
# generate cluster labels based on proportions
group <- sample(paste0("c", 0:(n_clusters-1)),
size = n_cells, replace = TRUE, prob = cluster_prop)
# simulate (no group effects)
params <- newSplatParams(batchCells = n_cells, nGenes = n_genes_sim)
sce_H0 <- splatSimulate(params, method = "single", verbose = FALSE)
# add groups after simulation
colData(sce_H0)$cluster <- factor(group, levels = paste0("c", 0:(n_clusters-1)))
# rename one gene to col1a1b
rownames(sce_H0)[1] <- "col1a1b"
# create logcounts
sce_H0 <- logNormCounts(sce_H0)
expr <- as.numeric(logcounts(sce_H0)["col1a1b", ])
df0 <- data.frame(expr = expr, cluster = colData(sce_H0)$cluster)
fit_H0 <- lm(expr ~ cluster, data = df0)
anova(fit_H0)
summary(fit_H0)$r.squared
summary(fit_H0)$coefficients
# H0 residual plot
plot(fitted(fit_H0), resid(fit_H0),
xlab="Fitted values", ylab="Residuals",
main="Residuals vs fitted (simulated H0)")
abline(h=0, lty=2)
# start WITH H0, but then add a cluster-specific shift ONLY to col1a1b
sce_H1 <- sce_H0
expr1 <- logcounts(sce_H1)["col1a1b", ]
# make clusters c0 and c1 higher tghan others
shift <- ifelse(colData(sce_H1)$cluster %in% c("c0","c1"), 1.0, 0)  # +1 log-unit
logcounts(sce_H1)["col1a1b", ] <- expr1 + shift
# test the H1 hypothesis
expr <- as.numeric(logcounts(sce_H1)["col1a1b", ])
df1 <- data.frame(expr = expr, cluster = colData(sce_H1)$cluster)
fit_H1 <- lm(expr ~ cluster, data = df1)
anova(fit_H1)
summary(fit_H1)$r.squared
summary(fit_H1)$coefficients
# H1 residual plot
plot(fitted(fit_H1), resid(fit_H1),
xlab="Fitted values", ylab="Residuals",
main="Residuals vs fitted (simulated H1)")
abline(h=0, lty=2)
## 3) Data + model fit overlaid (H0)
df0 <- data.frame(
expr    = as.numeric(logcounts(sce_H0)["col1b1a", ]),
cluster = colData(sce_H0)$cluster
)
## 3) Data + model fit overlaid (H0)
df0 <- data.frame(
expr    = as.numeric(logcounts(sce_H0)["col1b1a", ]),
cluster = colData(sce_H0)$cluster
)
# 3) Data + model fit overlaid (H0)
gene <- "col1a1b"
df0 <- data.frame(expr = as.numeric(logcounts(sce_H0)[gene, ]),
cluster = colData(sce_H0)$cluster)
df0$fit <- predict(fit_H0, newdata = df0)
ggplot(df0, aes(cluster, expr)) +
geom_point(position = position_jitter(width = 0.2), alpha = 0.25) +
geom_point(data = unique(df0[c("cluster","fit")]),
aes(y = fit), size = 2) +
labs(title = "Simulated H0: data + fitted means", x = "Cluster", y = "log-expression")
# 3) Data + model fit overlaid (H1)
df1 <- data.frame(expr = as.numeric(logcounts(sce_H1)[gene, ]),
cluster = colData(sce_H1)$cluster)
df1$fit <- predict(fit_H1, newdata = df1)
ggplot(df1, aes(cluster, expr)) +
geom_point(position = position_jitter(width = 0.2), alpha = 0.25) +
geom_point(data = unique(df1[c("cluster","fit")]),
aes(y = fit), size = 2) +
labs(title = "Simulated H1: data + fitted means", x = "Cluster", y = "log-expression")
# GLM on one gene across all clusters (11 dpf)
DefaultAssay(seurat_obj_11dpf) <- "SCT"  # use normalized expression values
geneX <- "col1a1b" #previously identified marker gene
stopifnot(geneX %in% rownames(seurat_obj_11dpf))
# Extract log-normalized expression
expr <- as.numeric(GetAssayData(seurat_obj_11dpf, slot = "data")[geneX, ])
# Build a modeling dataframe
df <- seurat_obj_11dpf@meta.data %>%
mutate(
expr = expr,
seurat_clusters = factor(seurat_clusters)  # categorical predictor
) %>%
select(expr, seurat_clusters)
# Fit the general linear model
fit_real <- lm(expr ~ seurat_clusters, data = df)
# Data + model fit overlaid
df$fit <- predict(fit_real, newdata = df)
ggplot(df, aes(seurat_clusters, expr)) +
geom_point(position = position_jitter(width = 0.2), alpha = 0.25) +
geom_point(data = dplyr::distinct(df, seurat_clusters, fit),
aes(y = fit), size = 2) +
labs(title = "Real data: col1a1b + fitted means",
x = "Cluster", y = "log-expression")
# Report coefficients + p-values
summary(fit_real)$coefficients
# plot residuals
plot(fitted(fit_real), resid(fit_real),
xlab = "Fitted values", ylab = "Residuals",
main = "Residuals vs. fitted (real data)")
abline(h = 0, lty = 2)
# Data + model fit plot: observed vs predicted
df$pred <- predict(fit_real, newdata = df)
ggplot(df, aes(x = pred, y = expr)) +
geom_point(alpha = 0.35) +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(title = "Observed vs. predicted col1a1b expression (real data)",
x = "Predicted expression", y = "Observed expression")
# Data + model fit overlaid
df$fit <- predict(fit_real, newdata = df)
ggplot(df, aes(seurat_clusters, expr)) +
geom_point(position = position_jitter(width = 0.2), alpha = 0.25) +
geom_point(data = dplyr::distinct(df, seurat_clusters, fit),
aes(y = fit), size = 2) +
labs(title = "Real data: col1a1b + fitted means",
x = "Cluster", y = "log-expression")
summary(fit_real)$coefficients
setwd("~/CMSE890_602/Semester_project_Leow")
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE)
library(testthat)
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
set.seed(params$seed)
source("R scripts/load_data.R")
embryo_11dpf <- load_monocle_objects("data/embryo_11dpf")
